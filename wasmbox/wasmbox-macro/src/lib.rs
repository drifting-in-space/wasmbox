extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{ItemFn, ReturnType};

fn wasmbox_impl(item: &proc_macro2::TokenStream) -> proc_macro2::TokenStream {
    let func: ItemFn =
        syn::parse2(item.clone()).expect("#[wasmbox] should annotate a function.");

    if &func.sig.ident.to_string() != "run" {
        panic!("#[wasmbox] should annotate a function called `run`.");
    }

    if func.sig.asyncness.is_none() {
        panic!("#[wasmbox] should annotate an async function.");
    }

    if let ReturnType::Default = func.sig.output {
    } else {
        panic!("The function wrapped by #[wasmbox] should not have a return type.");
    }

    let inputs: Vec<_> = func.sig.inputs.iter().collect();
    if inputs.len() != 1 {
        panic!("The function wrapped by #[wasmbox] should have exactly one argument (a WasmboxContext.)");
    }

    let inputs = func.sig.inputs;
    let block = func.block;

    quote! {
        mod _wasmbox_macro_autogenerated {
            // extern crate alloc;

            use super::*;
            use wasmbox::prelude::*;
            use std::pin::Pin;
            use std::boxed::Box;
            use std::future::Future;

            #[derive(Default)]
            struct WasmBoxImpl;

            impl AsyncWasmBox for WasmBoxImpl {
                type Input = String;
                type Output = String;
                
                fn run<'async_trait>(#inputs) -> Pin<Box<dyn Future<Output = ()> + Send + 'async_trait>> where
                    Self: 'async_trait
                {
                    Box::pin(async move {
                        #block
                    })
                }
            }

            #[no_mangle]
            extern "C" fn wasmbox_initialize() {
                initialize_async::<WasmBoxImpl>();
            }
        }
    }
}

#[proc_macro_attribute]
pub fn wasmbox(_attr: TokenStream, item: TokenStream) -> TokenStream {
    wasmbox_impl(&item.into()).into()
}